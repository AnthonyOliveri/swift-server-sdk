//
//  FormParametersAPI.swift
//  TestSdkStandalone
//
//  Generated by IBM Bluemix Mobile DevEx.
//


import Foundation
import ObjectMapper
import SimpleHttpClient


public class FormParametersAPI: TestSdkStandaloneUtility {


    /**
        

        - parameter string: 
        - parameter float: 
        - parameter double: 
        - parameter integer: 
        - parameter long: 
        - parameter boolean: 
        - parameter csvArray: 
        - parameter ssvArray: 
        - parameter tsvArray: 
        - parameter pipesArray: 
        - parameter multi: 
        - parameter date: 
        - parameter dateTime: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testAllTheThingsFormData(string: String, float: Float, double: Double, integer: Int, long: Int64, boolean: Bool, csvArray: [String], ssvArray: [String], tsvArray: [String], pipesArray: [String], multi: [String], date: Date, dateTime: Date, completionHandler: @escaping (_ returnedData: FormModel?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/multipart/allTheThings"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["string"] = string.description
        formParameters["float"] = float.description
        formParameters["double"] = double.description
        formParameters["integer"] = integer.description
        formParameters["long"] = long.description
        formParameters["boolean"] = boolean.description
        formParameters["csv-array"] = csvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "csv"))\(string)"
        }
        formParameters["ssv-array"] = ssvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "ssv"))\(string)"
        }
        formParameters["tsv-array"] = tsvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "tsv"))\(string)"
        }
        formParameters["pipes-array"] = pipesArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "pipes"))\(string)"
        }
        var parameterString = multi[0]
        parameterString.append("&")
        parameterString.append(
            multi.suffix(from: 1)
                .map { (value) -> String in
                    "multi=\(value)"
            }
                .reduce("") { (result, string) -> String in
                    result.isEmpty ? string : "\(result)&\(string)"
            }
        )
        formParameters["multi"] = parameterString
        formParameters["date"] = date.description
        formParameters["dateTime"] = dateTime.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: FormModel.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter string: 
        - parameter float: 
        - parameter double: 
        - parameter integer: 
        - parameter long: 
        - parameter boolean: 
        - parameter csvArray: 
        - parameter ssvArray: 
        - parameter tsvArray: 
        - parameter pipesArray: 
        - parameter date: 
        - parameter dateTime: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testAllTheThingsUrlEncoded(string: String, float: Float, double: Double, integer: Int, long: Int64, boolean: Bool, csvArray: [String], ssvArray: [String], tsvArray: [String], pipesArray: [String], date: Date, dateTime: Date, completionHandler: @escaping (_ returnedData: FormModel?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/allTheThings"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["string"] = string.description
        formParameters["float"] = float.description
        formParameters["double"] = double.description
        formParameters["integer"] = integer.description
        formParameters["long"] = long.description
        formParameters["boolean"] = boolean.description
        formParameters["csv-array"] = csvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "csv"))\(string)"
        }
        formParameters["ssv-array"] = ssvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "ssv"))\(string)"
        }
        formParameters["tsv-array"] = tsvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "tsv"))\(string)"
        }
        formParameters["pipes-array"] = pipesArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "pipes"))\(string)"
        }
        formParameters["date"] = date.description
        formParameters["dateTime"] = dateTime.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: FormModel.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter binary: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testBinaryFormData(binary: Data, completionHandler: @escaping (_ returnedData: Data?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/binary"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["binary"] = binary.base64EncodedString(options: [])

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Data.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter binary: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testBinaryUrlEncoded(binary: Data, completionHandler: @escaping (_ returnedData: Data?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/binary"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["binary"] = binary.base64EncodedString(options: [])

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Data.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter boolean: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testBooleanFormData(boolean: Bool, completionHandler: @escaping (_ returnedData: Bool?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/boolean"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["boolean"] = boolean.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Bool.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter boolean: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testBooleanUrlEncoded(boolean: Bool, completionHandler: @escaping (_ returnedData: Bool?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/boolean"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["boolean"] = boolean.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Bool.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter byte: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testByteFormData(byte: Data, completionHandler: @escaping (_ returnedData: Data?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/byte"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["byte"] = byte.base64EncodedString(options: [])

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Data.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter byte: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testByteUrlEncoded(byte: Data, completionHandler: @escaping (_ returnedData: Data?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/byte"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["byte"] = byte.base64EncodedString(options: [])

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Data.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter csvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testCSVFormData(csvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/csv"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["csv-array"] = csvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "csv"))\(string)"
        }

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter csvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testCSVUrlEncoded(csvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/csv"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["csv-array"] = csvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "csv"))\(string)"
        }

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter date: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDateFormData(date: Date, completionHandler: @escaping (_ returnedData: Date?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/date"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["date"] = date.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Date.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter dateTime: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDateTimeFormData(dateTime: Date, completionHandler: @escaping (_ returnedData: Date?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/dateTime"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["dateTime"] = dateTime.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Date.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter dateTime: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDateTimeUrlEncoded(dateTime: Date, completionHandler: @escaping (_ returnedData: Date?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/dateTime"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["dateTime"] = dateTime.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Date.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter date: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDateUrlEncoded(date: Date, completionHandler: @escaping (_ returnedData: Date?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/date"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["date"] = date.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Date.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter double: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDoubleFormData(double: Double, completionHandler: @escaping (_ returnedData: Double?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/double"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["double"] = double.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Double.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter double: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDoubleUrlEncoded(double: Double, completionHandler: @escaping (_ returnedData: Double?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/double"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["double"] = double.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Double.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter file: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testFileFormData(file: URL, completionHandler: @escaping (_ returnedData: URL?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) throws {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/file"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        let formParameters: [String:String?] = [:]

        var requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        requestBody.append(("\(boundary)\r\n" +
                    "Content-Disposition: form-data; name=\"file\"; filename=\"\(file.lastPathComponent)\"\r\n" +
                    "\r\n").data(using: .utf8)!)
        try requestBody.append(Data(contentsOf: file as URL))
        requestBody.append("\r\n".data(using: .utf8)!)

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: URL.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter file: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testFileUrlEncoded(file: URL, completionHandler: @escaping (_ returnedData: URL?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) throws {

        let path = "/params/form/urlencoded/file"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        let formParameters: [String:String?] = [:]

        var requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        requestBody.append("&file=".data(using: .utf8)!)
        try requestBody.append(Data(contentsOf: file as URL))

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: URL.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter float: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testFloatFormData(float: Float, completionHandler: @escaping (_ returnedData: Float?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/float"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["float"] = float.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Float.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter float: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testFloatUrlEncoded(float: Float, completionHandler: @escaping (_ returnedData: Float?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/float"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["float"] = float.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Float.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter integer: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testIntegerFormData(integer: Int, completionHandler: @escaping (_ returnedData: Int?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/integer"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["integer"] = integer.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Int.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter integer: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testIntegerUrlEncoded(integer: Int, completionHandler: @escaping (_ returnedData: Int?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/integer"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["integer"] = integer.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Int.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter long: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testLongFormData(long: Int64, completionHandler: @escaping (_ returnedData: Int64?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/long"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["long"] = long.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Int64.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter long: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testLongUrlEncoded(long: Int64, completionHandler: @escaping (_ returnedData: Int64?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/long"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["long"] = long.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Int64.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter multi: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testMultiFormData(multi: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/multi"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        var parameterString = multi[0]
        parameterString.append("&")
        parameterString.append(
            multi.suffix(from: 1)
                .map { (value) -> String in
                    "multi=\(value)"
            }
                .reduce("") { (result, string) -> String in
                    result.isEmpty ? string : "\(result)&\(string)"
            }
        )
        formParameters["multi"] = parameterString

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter multi: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testMultiUrlEncoded(multi: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/multi"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        var parameterString = multi[0]
        parameterString.append("&")
        parameterString.append(
            multi.suffix(from: 1)
                .map { (value) -> String in
                    "multi=\(value)"
            }
                .reduce("") { (result, string) -> String in
                    result.isEmpty ? string : "\(result)&\(string)"
            }
        )
        formParameters["multi"] = parameterString

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter float: 
        - parameter double: 
        - parameter csvArray: 
        - parameter ssvArray: 
        - parameter tsvArray: 
        - parameter pipesArray: 
        - parameter multi: 
        - parameter date: 
        - parameter dateTime: 
        - parameter string: 
        - parameter integer: 
        - parameter long: 
        - parameter boolean: . If this parameter is not supplied, it defaults to false.
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testOptionalsFormData(float: Float, double: Double, csvArray: [String], ssvArray: [String], tsvArray: [String], pipesArray: [String], multi: [String], date: Date, dateTime: Date, string: String? = nil, integer: Int? = nil, long: Int64? = nil, boolean: Bool? = nil, completionHandler: @escaping (_ returnedData: FormModel?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/multipart/optionals"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["string"] = string?.description
        formParameters["float"] = float.description
        formParameters["double"] = double.description
        formParameters["integer"] = integer?.description
        formParameters["long"] = long?.description
        formParameters["boolean"] = boolean?.description
        formParameters["csv-array"] = csvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "csv"))\(string)"
        }
        formParameters["ssv-array"] = ssvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "ssv"))\(string)"
        }
        formParameters["tsv-array"] = tsvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "tsv"))\(string)"
        }
        formParameters["pipes-array"] = pipesArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "pipes"))\(string)"
        }
        var parameterString = multi[0]
        parameterString.append("&")
        parameterString.append(
            multi.suffix(from: 1)
                .map { (value) -> String in
                    "multi=\(value)"
            }
                .reduce("") { (result, string) -> String in
                    result.isEmpty ? string : "\(result)&\(string)"
            }
        )
        formParameters["multi"] = parameterString
        formParameters["date"] = date.description
        formParameters["dateTime"] = dateTime.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: FormModel.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter float: 
        - parameter double: 
        - parameter csvArray: 
        - parameter ssvArray: 
        - parameter tsvArray: 
        - parameter pipesArray: 
        - parameter date: 
        - parameter dateTime: 
        - parameter string: 
        - parameter integer: 
        - parameter long: 
        - parameter boolean: . If this parameter is not supplied, it defaults to false.
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testOptionalsUrlEncoded(float: Float, double: Double, csvArray: [String], ssvArray: [String], tsvArray: [String], pipesArray: [String], date: Date, dateTime: Date, string: String? = nil, integer: Int? = nil, long: Int64? = nil, boolean: Bool? = nil, completionHandler: @escaping (_ returnedData: FormModel?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/optionals"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["string"] = string?.description
        formParameters["float"] = float.description
        formParameters["double"] = double.description
        formParameters["integer"] = integer?.description
        formParameters["long"] = long?.description
        formParameters["boolean"] = boolean?.description
        formParameters["csv-array"] = csvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "csv"))\(string)"
        }
        formParameters["ssv-array"] = ssvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "ssv"))\(string)"
        }
        formParameters["tsv-array"] = tsvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "tsv"))\(string)"
        }
        formParameters["pipes-array"] = pipesArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "pipes"))\(string)"
        }
        formParameters["date"] = date.description
        formParameters["dateTime"] = dateTime.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: FormModel.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter pipesArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testPipesFormData(pipesArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/pipes"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["pipes-array"] = pipesArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "pipes"))\(string)"
        }

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter pipesArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testPipesUrlEncoded(pipesArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/pipes"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["pipes-array"] = pipesArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "pipes"))\(string)"
        }

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter ssvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testSSVFormData(ssvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/ssv"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["ssv-array"] = ssvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "ssv"))\(string)"
        }

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter ssvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testSSVUrlEncoded(ssvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/ssv"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["ssv-array"] = ssvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "ssv"))\(string)"
        }

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter string: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testStringFormData(string: String, completionHandler: @escaping (_ returnedData: String?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/string"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["string"] = string.description

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: String.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter string: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testStringUrlEncoded(string: String, completionHandler: @escaping (_ returnedData: String?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/string"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["string"] = string.description

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: String.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter tsvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testTSVFormData(tsvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let uuid = UUID()
        let boundary = "----\(uuid.uuidString)"

        let path = "/params/form/multipart/tsv"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "multipart/form-data; boundary=\(boundary)"

        var formParameters: [String:String?] = [:]
        formParameters["tsv-array"] = tsvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "tsv"))\(string)"
        }

        let requestBody = formParameters.map ({ (key, value) -> String in
            "\(boundary)\r\n" +
            "Content-Disposition: form-data; name=\"\(key)\"\r\n" +
            "\r\n" +
            "\(value)\r\n"
        })
        .reduce("", { (result, string) -> String in
            result + string
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter tsvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testTSVUrlEncoded(tsvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {

        let path = "/params/form/urlencoded/tsv"
        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"
        requestHeaders["Content-Type"] = "application/x-www-form-urlencoded"

        var formParameters: [String:String?] = [:]
        formParameters["tsv-array"] = tsvArray.reduce("") { (result, string) -> String in
            result.isEmpty ? string : "\(result)\(self.delimeter(forCollectionFormat: "tsv"))\(string)"
        }

        let requestBody = formParameters.map({ (key, value) -> String in
            "\(key)=\(value)"
        })
        .reduce("", { (result, string) -> String in
            result.isEmpty ? string : "\(result)&\(string)"
        })
        .data(using: .utf8)!

        HttpClient.sendRequest(to: httpResource, method: "PUT", headers: requestHeaders, data: requestBody) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error != nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }

}
