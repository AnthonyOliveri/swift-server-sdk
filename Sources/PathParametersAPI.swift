//
//  PathParametersAPI.swift
//  TestSdkStandalone
//
//  Generated by IBM Bluemix Mobile DevEx.
//


import Foundation
import ObjectMapper
import SimpleHttpClient


public class PathParametersAPI: TestSdkStandaloneUtility {


    /**
        

        - parameter string: 
        - parameter float: 
        - parameter double: 
        - parameter integer: 
        - parameter long: 
        - parameter boolean: 
        - parameter csvArray: 
        - parameter ssvArray: 
        - parameter tsvArray: 
        - parameter pipesArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testAllTheThingsPathParam(string: String, float: Float, double: Double, integer: Int, long: Int64, boolean: Bool, csvArray: [String], ssvArray: [String], tsvArray: [String], pipesArray: [String], completionHandler: @escaping (_ returnedData: PathModel?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/allTheThings/{string}/{float}/{double}/{integer}/{long}/{boolean}/{csv-array}/{ssv-array}/{tsv-array}/{pipes-array}"
        path = path.replacingOccurrences(of: "{string}", with: "\(string)")
        path = path.replacingOccurrences(of: "{float}", with: "\(float)")
        path = path.replacingOccurrences(of: "{double}", with: "\(double)")
        path = path.replacingOccurrences(of: "{integer}", with: "\(integer)")
        path = path.replacingOccurrences(of: "{long}", with: "\(long)")
        path = path.replacingOccurrences(of: "{boolean}", with: "\(boolean)")
        path = path.replacingOccurrences(of: "{csvArray}", with: "\(csvArray)")
        path = path.replacingOccurrences(of: "{ssvArray}", with: "\(ssvArray)")
        path = path.replacingOccurrences(of: "{tsvArray}", with: "\(tsvArray)")
        path = path.replacingOccurrences(of: "{pipesArray}", with: "\(pipesArray)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: PathModel.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter boolean: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testBooleanPathParam(boolean: Bool, completionHandler: @escaping (_ returnedData: Bool?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/boolean/{boolean}"
        path = path.replacingOccurrences(of: "{boolean}", with: "\(boolean)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Bool.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter csvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testCSVPathParam(csvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/csv/{csv-array}"
        path = path.replacingOccurrences(of: "{csvArray}", with: "\(csvArray)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter double: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testDoublePathParam(double: Double, completionHandler: @escaping (_ returnedData: Double?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/double/{double}"
        path = path.replacingOccurrences(of: "{double}", with: "\(double)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Double.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter float: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testFloatPathParam(float: Float, completionHandler: @escaping (_ returnedData: Float?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/float/{float}"
        path = path.replacingOccurrences(of: "{float}", with: "\(float)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Float.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter integer: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testIntegerPathParam(integer: Int, completionHandler: @escaping (_ returnedData: Int?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/integer/{integer}"
        path = path.replacingOccurrences(of: "{integer}", with: "\(integer)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Int.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter long: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testLongPathParam(long: Int64, completionHandler: @escaping (_ returnedData: Int64?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/long/{long}"
        path = path.replacingOccurrences(of: "{long}", with: "\(long)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: Int64.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter pipesArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testPipesPathParam(pipesArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/pipes/{pipes-array}"
        path = path.replacingOccurrences(of: "{pipesArray}", with: "\(pipesArray)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter ssvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testSSVPathParam(ssvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/ssv/{ssv-array}"
        path = path.replacingOccurrences(of: "{ssvArray}", with: "\(ssvArray)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter string: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testStringPathParam(string: String, completionHandler: @escaping (_ returnedData: String?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/string/{string}"
        path = path.replacingOccurrences(of: "{string}", with: "\(string)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: String.self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }


    /**
        

        - parameter tsvArray: 
        - parameter completionHandler: The callback that will be executed once the underlying HTTP call completes
        - parameter returnedData: The data that this method is retrieving from the server
        - parameter response: The HTTP response returned by the server
        - parameter error: An error that prevented a successful request
    */
    public static func testTSVPathParam(tsvArray: [String], completionHandler: @escaping (_ returnedData: [String]?, _ statusCode: Int?, _ responseHeaders: [String: String]?, _ error: HttpError?) -> Void) {


        var path = "/params/path/tsv/{tsv-array}"
        path = path.replacingOccurrences(of: "{tsvArray}", with: "\(tsvArray)")

        let components = URLComponents(string: self.basePath + path)

        let requestUrl: URL = components!.url!
        let splitUrl: [String] = requestUrl.absoluteString.components(separatedBy: "://")
        let httpResource = HttpResource(schema: splitUrl[0], host: splitUrl[1], port: nil, path: path)

        var requestHeaders: [String: String] = [:]
        requestHeaders["Accept"] = "application/json"

        HttpClient.sendRequest(to: httpResource, method: "GET", headers: requestHeaders) {
            (error: HttpError?, status: Int?, headers: [String: String]?, data: Data?) in

            guard status != nil else {
                completionHandler(nil, nil, headers, error)
                return
            }

            guard error == nil else {
                completionHandler(nil, status, headers, error)
                return
            }

            if 200 ..< 300 ~= status!,
               status == 200,
               let data = data {

                let returnValue = extractResponseFromData(data: data, type: [String].self)
                completionHandler(returnValue, status, headers, error)
            } else {
                completionHandler(nil, status, headers, error)
            }
        }

    }

}
